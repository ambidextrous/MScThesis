// The translator takes the tree generated by the parser and reads through
// it recursively to extract all of the information required to write the
// API and the translation. The translator makes two passes through the
// protocol, one going forwards and the other going backwards. The forward
// pass collects most of the required sequential and message data, the
// backward pass adds information indicating when a message at the end of
// a conversation needs to be followed by a ``jump'' back up the tree
// rather than protocol termination. The translator collects all of this
// information in a structure composed of arrays of structures representing
// each of the element types that make up the protocol. In order to
// improve the efficiency of subsequent calculations, the translator then
// generates a hashmap linking to allow constant time access to these
// structures using their unique identifier strings.

// input: struct tree descending from Protocol root node

// output: []MessagesData containing arrays ([]RecData, []ParallelData,
// etc) and maps (map[string]*RecData, map[string]*ParallelData, etc.)

package main

import (
	"errors"
	"log"
	"strconv"
)

type AffixData struct {
	Suffixes           []string
	ParentIsChoice     bool
	RecId              string
	RecName            string
	RecFirstStructId   string
	RecFirstStructType string
	InRecBlock         bool
	InParBlock         bool
	ParentIsRecBlock   bool
}

func ZeroRoleCounters(s *SequenceCountingData) {
	for _, rc := range s.RoleCounters {
		rc.Counter = 0
	}
}

type MessageData struct {
	UniqueId            string
	Protagonist         string
	MethodNameBase      string
	Suffix              []string
	Parameters          []string
	FromBase            string
	ToBase              string
	ChanName            string
	SubsequentSuffix    []string
	SeqCounter          int
	IsChoiceOption      bool
	ChoiceChanName      string
	WhereToIfBranchEnds WhereToIfBranchEnds
	RecId               string
	RecName             string
	FollowingContinueId string
	ContinueToStruct    string
	InRecBlock          bool
}

type ChoiceData struct {
	UniqueId            string
	Protagonist         string
	Chooser             string
	Suffix              []string
	OptionIds           []string
	OptionSuffixes      []string
	NextId              string
	NextType            string
	WhereToIfBranchEnds WhereToIfBranchEnds
	RecId               string
	RecName             string
	InRecBlock          bool
}

func GetStringSliceAsString(slice []string) string {
	str := ""
	for _, s := range slice {
		str += s
	}
	return str
}

func GetSuffixForUniqueId(id string, m *MessagesData) string {
	retVal := ""
	for _, message := range m.Messages {
		if message.UniqueId == id {
			retVal = GetStringSliceAsString(message.Suffix)
		}
	}
	for _, choice := range m.Choices {
		if choice.UniqueId == id {
			retVal = GetStringSliceAsString(choice.Suffix)
		}
	}
	for _, par := range m.Parallels {
		if par.UniqueId == id {
			retVal = GetStringSliceAsString(par.Suffix)
		}
	}
	return retVal
}

func SetChoiceData(choi *Choice, choiceId string, s *SequenceCountingData, m *MessagesData, a AffixData) {
	for _, choiceData := range m.Choices {
		if choiceData.UniqueId == choiceId {
			optionIds := make([]string, 0)
			optionSuffixes := make([]string, 0)
			for _, conv := range choi.Convs {
				firstNode := conv.Nodes[0]
				if firstNode.Cat == "message" {
					optionIds = append(optionIds, firstNode.Mess.Id)
					suffix := GetSuffixForUniqueId(firstNode.Mess.Id, m)
					optionSuffixes = append(optionSuffixes, suffix)
				}
				if firstNode.Cat == "choice" {
					optionIds = append(optionIds, firstNode.Choice.Id)
					suffix := GetSuffixForUniqueId(firstNode.Choice.Id, m)
					optionSuffixes = append(optionSuffixes, suffix)
				}
				if firstNode.Cat == "par" {
					optionIds = append(optionIds, firstNode.Par.Id)
					suffix := GetSuffixForUniqueId(firstNode.Par.Id, m)
					optionSuffixes = append(optionSuffixes, suffix)
				}
			}
			choiceData.OptionIds = optionIds
			choiceData.OptionSuffixes = optionSuffixes
		}
	}
}

func SetParallelData(par *Parallel, parId string, s *SequenceCountingData, m *MessagesData, a AffixData) {
	for _, parallelData := range m.Parallels {
		if parallelData.UniqueId == parId {
			optionIds := make([]string, 0)
			optionSuffixes := make([]string, 0)
			for _, conv := range par.Convs {
				firstNode := conv.Nodes[0]
				if firstNode.Cat == "message" {
					optionIds = append(optionIds, firstNode.Mess.Id)
					suffix := GetSuffixForUniqueId(firstNode.Mess.Id, m)
					optionSuffixes = append(optionSuffixes, suffix)
				}
				if firstNode.Cat == "choice" {
					optionIds = append(optionIds, firstNode.Choice.Id)
					suffix := GetSuffixForUniqueId(firstNode.Choice.Id, m)
					optionSuffixes = append(optionSuffixes, suffix)
				}
				if firstNode.Cat == "par" {
					optionIds = append(optionIds, firstNode.Par.Id)
					suffix := GetSuffixForUniqueId(firstNode.Par.Id, m)
					optionSuffixes = append(optionSuffixes, suffix)
				}
			}
			parallelData.OptionIds = optionIds
			parallelData.OptionSuffixes = optionSuffixes
		}
	}
}

func SetChoicesData(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData) {
	for _, node := range c.Nodes {
		if node.Cat == "choice" {
			choiceId := node.Choice.Id
			SetChoiceData(node.Choice, choiceId, s, m, a)
		}
	}
}

func SetParallelsData(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData) {
	for _, node := range c.Nodes {
		if node.Cat == "par" {
			parId := node.Par.Id
			SetParallelData(node.Par, parId, s, m, a)
		}
	}
}

type ParallelData struct {
	UniqueId            string
	Protagonist         string
	Suffix              []string
	OptionIds           []string
	OptionSuffixes      []string
	ChanNameBase        string
	SubsequentSuffix    []string
	WhereToIfBranchEnds WhereToIfBranchEnds
	RecId               string
	RecName             string
	InRecBlock          bool
}

func SetMessagesData(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData) {
	messageCounter := 0
	for i, node := range c.Nodes {
		if node.Cat == "message" {
			messageCounter++
			suffix := append(a.Suffixes, strconv.Itoa(messageCounter))
			suffixCopy := make([]string, 0)
			for _, s := range suffix {
				suffixCopy = append(suffixCopy, s)
			}
			mess := node.Mess
			chanType := ""
			if len(mess.Types) == 0 {
				chanType = "_Empty"
				//chanType = "_bool"
			} else {
				for _, t := range mess.Types {
					chanType += "_" + t
				}
			}
			isChoiceOption := false
			choiceChanName := ""
			if i == 0 && a.ParentIsChoice {
				isChoiceOption = true
				choiceChanName = mess.Name + "From" + mess.RoleTo + "To" + mess.RoleTo + chanType
			}
			chanName := mess.Name + "From" + mess.RoleFrom + "To" + mess.RoleTo + chanType
			followingContinueId := ""
			if i == len(c.Nodes)-2 && c.Nodes[len(c.Nodes)-1].Cat == "continue" {
				followingContinueId = c.Nodes[len(c.Nodes)-1].Cont.Id
			}
			newMessageData := &MessageData{UniqueId: mess.Id, Protagonist: mess.Protagonist, MethodNameBase: mess.Name, Suffix: suffixCopy, Parameters: mess.Types, FromBase: mess.From, ToBase: mess.To, ChanName: chanName, SeqCounter: messageCounter, IsChoiceOption: isChoiceOption, ChoiceChanName: choiceChanName, RecId: a.RecId, RecName: a.RecName, FollowingContinueId: followingContinueId, InRecBlock: a.InRecBlock}
			m.Messages = append(m.Messages, newMessageData)
		}
	}
}

func TransMessages(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData) {
	ZeroRoleCounters(s)
	SetMessagesData(c, s, m, a)
}

func GetNextLetter(index int) string {
	letters := [26]string{"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"}
	letterIndex := index % len(letters)
	letterRepetitions := index / len(letters)
	additionalSuffix := "_"
	for i := 0; i < letterRepetitions+1; i++ {

		additionalSuffix += letters[letterIndex]
	}
	return additionalSuffix
}

func TransPar(p *Parallel, s *SequenceCountingData, m *MessagesData, a AffixData) {
	originalSuffix := a.Suffixes
	for i, conv := range p.Convs {
		a.Suffixes = originalSuffix
		additionalSuffix := GetNextLetter(i)
		a.Suffixes = append(a.Suffixes, additionalSuffix)
		a.InParBlock = true
		TransConversation(conv, s, m, a)
	}
}

func NumberPars(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData) {
	originalSuffix := a.Suffixes
	parCounter := 0
	for i := 0; i < len(c.Nodes); i++ {
		a.Suffixes = originalSuffix
		n := c.Nodes[i]
		if n.Cat == "par" {
			parCounter++
			parSuffix := "_par" + strconv.Itoa(parCounter)
			a.Suffixes = append(a.Suffixes, parSuffix)
			newParData := &ParallelData{UniqueId: n.Par.Id, Protagonist: n.Par.Protagonist, ChanNameBase: GetStringSliceAsString(a.Suffixes), Suffix: a.Suffixes, RecId: a.RecId, RecName: a.RecName, InRecBlock: a.InRecBlock}
			m.Parallels = append(m.Parallels, newParData)
			TransPar(n.Par, s, m, a)
		}
	}
}

func GetRecDataWithName(name string, m *MessagesData) (*RecData, error) {
	if m.MapsGenerated {
		recData, ok := m.RecMap[name]
		if ok {
			return recData, nil
		} else {
			return recData, errors.New("RecData with name " + name + " not found.")
		}
	}
	var retVal *RecData
	for _, rec := range m.Recs {
		if rec.Name == name {
			return rec, nil
		}
	}
	return retVal, errors.New("GetRecWithName() failed to find RecData with name: " + name)
}

func GenerateContinueData(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData) {
	potentialContinue := c.Nodes[len(c.Nodes)-1]
	if potentialContinue.Cat == "continue" {
		cont := potentialContinue.Cont
		rec, err := GetRecDataWithName(cont.Name, m)
		if err != nil {
			log.Fatal(err)
		}
		recInParserTree := rec.RecInParserTree
		continueData := &ContinueData{UniqueId: cont.Id, Name: cont.Name, Rec: recInParserTree}
		m.Continues = append(m.Continues, continueData)
	}
}

func GetFirstStructNameFromRecData(rec *Rec, m *MessagesData) string {
	name := ""
	firstNode := rec.Conv.Nodes[0]
	if firstNode.Cat == "message" {
		mess, err := GetMessageDataWithId(m, firstNode.Mess.Id)
		if err != nil {
			log.Fatal(err)
		}
		name = mess.Protagonist + GetStringSliceAsString(AddUnderscoreSeparatorBetweenIntStrings(mess.Suffix))
	} else if firstNode.Cat == "choice" {
		choi, err := GetChoiceDataWithId(m, firstNode.Choice.Id)
		if err != nil {
			log.Fatal(err)
		}
		name = choi.Protagonist + CutStringAfterLetter(choi.OptionSuffixes[0], "_")
	} else if firstNode.Cat == "par" {
		par, err := GetParallelDataWithId(m, firstNode.Par.Id)
		if err != nil {
			log.Fatal(err)
		}
		name = par.Protagonist + CutStringAfterLetter(par.OptionSuffixes[0], "_") + "ADDINGPARSUFFIX"
	} else {
		log.Fatal("Unknown cat " + firstNode.Cat + " encountered by GetFirstStructNameFromRecData")
	}
	return name
}

func TransContinues(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData) {
	potentialConv := c.Nodes[len(c.Nodes)-1]
	if potentialConv.Cat == "continue" {
		rec, err := GetRecDataWithName(potentialConv.Name, m)
		if err != nil {
			log.Fatal(err)
		}
		firstId := rec.FirstStructId
		firstType := rec.FirstStructType
		firstStructName := ""
		firstStructType := ""
		firstStructId := ""
		if firstType == "message" {
			mess, err := GetMessageDataWithId(m, firstId)
			if err != nil {
				log.Fatal(err)
			}
			firstStructName = mess.Protagonist + GetStringSliceAsString(mess.Suffix)
			firstStructType = "message"
			firstStructId = mess.UniqueId
		} else if firstType == "choice" {
			choi, err := GetChoiceDataWithId(m, firstId)
			if err != nil {
				log.Fatal(err)
			}
			firstStructName = choi.Protagonist + CutStringAfterLetter(choi.OptionSuffixes[0], "_")
			firstStructType = "choice"
			firstStructId = choi.UniqueId
		} else if firstType == "parallel" {
			par, err := GetParallelDataWithId(m, firstId)
			if err != nil {
				log.Fatal(err)
			}
			firstStructName = par.Protagonist + CutStringAfterLetter(par.OptionSuffixes[0], "_")
			firstStructType = "parallel"
			firstStructId = par.UniqueId
		} else {
			log.Fatal("Unknown type " + firstType + " encountered in TransContinues()")
		}
		continueData := &ContinueData{UniqueId: potentialConv.Id, Name: potentialConv.Name, FirstStructName: firstStructName, FirstStructType: firstStructType, FirstStructId: firstStructId}
		m.Continues = append(m.Continues, continueData)
	}
}

type ContinueData struct {
	UniqueId         string
	Name             string
	FirstStructName  string
	FirstStructType  string
	FirstStructId    string
	Rec              *Rec
	ContinueToStruct string
}

func TransChoice(choi *Choice, s *SequenceCountingData, m *MessagesData, a AffixData) {
	originalSuffix := a.Suffixes
	for i, conv := range choi.Convs {
		a.Suffixes = originalSuffix
		additionalSuffix := GetNextLetter(i)
		a.Suffixes = append(a.Suffixes, additionalSuffix)
		a.ParentIsChoice = true
		TransConversation(conv, s, m, a)
	}
}

func NumberChoices(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData) {
	originalSuffix := a.Suffixes
	choiceCounter := 0
	for i := 0; i < len(c.Nodes); i++ {
		a.Suffixes = originalSuffix
		n := c.Nodes[i]
		if n.Cat == "choice" {
			choiceCounter++
			newSuffix := []string{"_choice", strconv.Itoa(choiceCounter)}
			a.Suffixes = append(a.Suffixes, newSuffix...)
			newChoiceData := &ChoiceData{UniqueId: n.Choice.Id, Protagonist: n.Choice.Protagonist, Chooser: n.Choice.Chooser, Suffix: newSuffix, InRecBlock: a.InRecBlock}
			m.Choices = append(m.Choices, newChoiceData)
			TransChoice(n.Choice, s, m, a)
		}
	}
}

func TransRec(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData) {
	originalSuffix := a.Suffixes
	recCounter := 0
	for i := 0; i < len(c.Nodes); i++ {
		a.Suffixes = originalSuffix
		n := c.Nodes[i]
		if n.Cat == "rec" {
			recCounter++
			newSuffix := []string{"_rec", strconv.Itoa(recCounter)}
			recInParserTree := n.Rec
			a.Suffixes = append(a.Suffixes, newSuffix...)
			firstStructId, firstStructType := GetFirstRecStructId(n.Rec)
			newRecData := &RecData{UniqueId: n.Rec.Id, Name: n.Rec.Name, RecInParserTree: recInParserTree, Protagonist: n.Rec.Protagonist, Suffix: newSuffix, AncestralRecId: a.RecId, AncestralRecName: a.RecName, FirstStructId: firstStructId, FirstStructType: firstStructType, InRecBlock: a.InRecBlock}
			m.Recs = append(m.Recs, newRecData)
			a.RecId = n.Rec.Id
			a.RecName = n.Rec.Name
			a.RecFirstStructId = firstStructId
			a.RecFirstStructType = firstStructType
			a.InRecBlock = true
			a.ParentIsRecBlock = true
			TransConversation(n.Rec.Conv, s, m, a)
		}
	}
}

func GetFirstRecStructId(rec *Rec) (string, string) {
	firstNode := rec.Conv.Nodes[0]
	if firstNode.Cat == "message" {
		return firstNode.Mess.Id, "message"
	} else if firstNode.Cat == "par" {
		return firstNode.Par.Id, "parallel"
	} else if firstNode.Cat == "choice" {
		return firstNode.Choice.Id, "choice"
	} else if firstNode.Cat == "rec" {
		return firstNode.Rec.Id, "rec"
	} else {
		log.Fatal("Unknown Cat encountered in GetFirstRecStruct(): ", firstNode.Cat)
	}
	return "", ""
}

type RecData struct {
	UniqueId            string
	Protagonist         string
	Name                string
	Suffix              []string
	AncestralRecId      string
	AncestralRecName    string
	FirstStructId       string
	FirstStructType     string
	WhereToIfBranchEnds WhereToIfBranchEnds
	RecInParserTree     *Rec
	InRecBlock          bool
}

func SetSequence(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData) {
	messageCounter := 0
	parCounter := 0
	choiceCounter := 0
	recCounter := 0
	// Forward pass
	for _, n := range c.Nodes {
		if n.Cat == "message" {
			messageCounter++
		}
		if n.Cat == "par" {
			parCounter++
		}
		if n.Cat == "choice" {
			choiceCounter++
		}
		if n.Cat == "rec" {
			recCounter++
		}
	}
	// Backward pass
	subsequentSuffix := make([]string, 0)
	for i := len(c.Nodes) - 1; i >= 0; i-- {
		if i == len(c.Nodes)-1 {

		}
		currentSuffix := make([]string, 0)
		n := c.Nodes[i]
		if n.Cat == "message" {
			messageData, err := GetMessageDataWithId(m, n.Mess.Id)
			if err != nil {
				log.Fatal(err)
			}
			if IsFinalElementInParallel(messageData, subsequentSuffix) {
				endParSuffix := []string{messageData.Protagonist}
				endParSuffix = append(endParSuffix, messageData.Suffix[:(len(messageData.Suffix)-2)]...)
				endParSuffix = append(endParSuffix, "_end")
				subsequentSuffix = CopyStringSlice(endParSuffix)
			}
			messageData.SubsequentSuffix = CopyStringSlice(subsequentSuffix)
			currentSuffix = append(a.Suffixes, strconv.Itoa(messageCounter))
			messageCounter--
		}
		if n.Cat == "par" {
			parallelData, err := GetParallelDataWithId(m, n.Par.Id)
			if err != nil {
				log.Fatal(err)
			}
			parallelData.SubsequentSuffix = CopyStringSlice(subsequentSuffix)
			new := []string{"_par", strconv.Itoa(parCounter), "_start"}
			currentSuffix = append(a.Suffixes, new...)
			parCounter--
		}
		if n.Cat == "choice" {
			new := []string{"_choice", strconv.Itoa(choiceCounter)}
			currentSuffix = append(a.Suffixes, new...)
			choiceCounter--
		}
		if n.Cat == "rec" {
			additionalSuffix := ""
			typeFollowing := n.Rec.Conv.Nodes[0].Cat
			if typeFollowing == "message" {
				additionalSuffix = "_1"
			} else if typeFollowing == "choice" {
				additionalSuffix = "_choice1"
			} else {
				log.Fatal("Unknown type encountered in SetSequence(): ", typeFollowing)
			}
			new := []string{"_rec", strconv.Itoa(recCounter) + additionalSuffix}
			currentSuffix = append(a.Suffixes, new...)
			recCounter--
		}
		subsequentSuffix = CopyStringSlice(currentSuffix)
	}
	CopyStringSlice(subsequentSuffix) // subsequentSuffix must be used in same scope as declared for code to compile
}

func IsFinalElementInParallel(messageData *MessageData, slice []string) bool {
	if len(slice) == 0 {
		if len(messageData.Suffix) > 2 {
			potentialParIdentifier := messageData.Suffix[len(messageData.Suffix)-3]
			if len(potentialParIdentifier) > 4 {
				if potentialParIdentifier[:4] == "_par" {
					return true
				}
			}
		}
	}
	return false
}

func CopyStringSlice(oldSlice []string) []string {
	newSlice := make([]string, 0)
	for _, str := range oldSlice {
		newSlice = append(newSlice, str)
	}
	return newSlice
}

func GetParallelDataWithId(m *MessagesData, id string) (*ParallelData, error) {
	if m.MapsGenerated {
		parallelData, ok := m.ParallelMap[id]
		if ok {
			return parallelData, nil
		} else {
			return parallelData, errors.New("ParallelData with id " + id + " not found.")
		}
	}
	var parallelData *ParallelData
	for _, par := range m.Parallels {
		if id == par.UniqueId {
			return par, nil
		}
	}
	return parallelData, errors.New("ParallelData with id " + id + "not found.")
}

func GetMessageDataWithId(m *MessagesData, id string) (*MessageData, error) {
	if m.MapsGenerated {
		messageData, ok := m.MessageMap[id]
		if ok {
			return messageData, nil
		} else {
			return messageData, errors.New("MessageData with id " + id + " not found.")
		}
	}
	var messageData *MessageData
	for _, mess := range m.Messages {
		if id == mess.UniqueId {
			return mess, nil
		}
	}
	return messageData, errors.New("MessageData with id " + id + " not found.")
}

func GetChoiceDataWithId(m *MessagesData, id string) (*ChoiceData, error) {
	if m.MapsGenerated {
		choiceData, ok := m.ChoiceMap[id]
		if ok {
			return choiceData, nil
		} else {
			return choiceData, errors.New("ChoiceData with id " + id + " not found.")
		}
	}
	var choiceData *ChoiceData
	for _, choice := range m.Choices {
		if id == choice.UniqueId {
			return choice, nil
		}
	}
	return choiceData, errors.New("ChoiceData with id " + id + " not found.")
}

func GetRecDataWithId(m *MessagesData, id string) (*RecData, error) {
	var recData *RecData
	for _, rec := range m.Recs {
		if id == rec.UniqueId {
			return rec, nil
		}
	}
	return recData, errors.New("RecData with id " + id + "not found.")
}

func GetContinueDataWithId(m *MessagesData, id string) (*ContinueData, error) {
	if m.MapsGenerated {
		continueData, ok := m.ContinueMap[id]
		if ok {
			return continueData, nil
		} else {
			return continueData, errors.New("ContinueData with id " + id + " not found.")
		}
	}
	var continueData *ContinueData
	for _, cont := range m.Continues {
		if id == cont.UniqueId {
			return cont, nil
		}
	}
	return continueData, errors.New("ContinueData with id " + id + "not found.")
}

type ConversationElementData struct {
	Type     string
	UniqueId string
}

type ConversationData struct {
	UniqueId                 string
	ConversationElementsData []*ConversationElementData
	Protagonist              string
	Suffix                   []string
	RecId                    string
	RecName                  string
	InRecBlock               bool
	InParBlock               bool
	ParentIsRecBlock         bool
}

func SetConversationData(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData, inParBlock bool, parentIsRecBlock bool) {
	convElements := make([]*ConversationElementData, 0)
	for _, node := range c.Nodes {
		var element *ConversationElementData
		if node.Cat == "message" {
			element = &ConversationElementData{Type: "message", UniqueId: node.Mess.Id}
		} else if node.Cat == "choice" {
			element = &ConversationElementData{Type: "choice", UniqueId: node.Choice.Id}
		} else if node.Cat == "par" {
			element = &ConversationElementData{Type: "parallel", UniqueId: node.Par.Id}
		} else if node.Cat == "rec" {
			element = &ConversationElementData{Type: "rec", UniqueId: node.Rec.Id}
		} else if node.Cat == "continue" {
			element = &ConversationElementData{Type: "continue", UniqueId: node.Cont.Id}
		} else {
			log.Fatal("Unknown Cat encountered in SetConversationData(): " + node.Cat)
		}
		convElements = append(convElements, element)
	}
	convSuffix := CopyStringSlice(a.Suffixes)
	conversationData := &ConversationData{UniqueId: c.Id, ConversationElementsData: convElements, Protagonist: c.Protagonist, Suffix: convSuffix, RecId: a.RecId, RecName: a.RecName, InRecBlock: a.InRecBlock, InParBlock: inParBlock, ParentIsRecBlock: parentIsRecBlock}
	m.Conversations = append(m.Conversations, conversationData)
}

func TransConversation(c *Conversation, s *SequenceCountingData, m *MessagesData, a AffixData) {
	inParBlock := a.InParBlock
	a.InParBlock = false
	parentIsRecBlock := a.ParentIsRecBlock
	a.ParentIsRecBlock = false
	TransMessages(c, s, m, a)
	GenerateContinueData(c, s, m, a)
	a.ParentIsChoice = false
	NumberPars(c, s, m, a)
	NumberChoices(c, s, m, a)
	TransRec(c, s, m, a)
	SetSequence(c, s, m, a)
	SetChoicesData(c, s, m, a)
	SetParallelsData(c, s, m, a)
	SetConversationData(c, s, m, a, inParBlock, parentIsRecBlock)
}

func AddRolesToCounters(l *Local, s *SequenceCountingData) {
	for _, role := range l.Roles {
		rc := &RoleCountingData{Name: role.Name}
		s.RoleCounters = append(s.RoleCounters, rc)
	}
}

func TransLocal(l *Local, m *MessagesData) {
	s := &SequenceCountingData{}
	s.RoleCounters = make([]*RoleCountingData, 0)
	AddRolesToCounters(l, s)
	a := AffixData{}
	a.Suffixes = make([]string, 0)
	TransConversation(l.Conv, s, m, a)
}

func TransTree(p *Protocol) *MessagesData {
	m := &MessagesData{}
	m.Messages = make([]*MessageData, 0)
	m.Choices = make([]*ChoiceData, 0)
	m.Parallels = make([]*ParallelData, 0)
	m.Conversations = make([]*ConversationData, 0)
	m.Recs = make([]*RecData, 0)
	m.Continues = make([]*ContinueData, 0)
	for _, loc := range p.Locals {
		l := loc
		TransLocal(l, m)
	}
	return m
}

func SetParallelGoToIfBranchEnds(parallel *Parallel, m *MessagesData, w WhereToIfBranchEnds) {
	for _, conv := range parallel.Convs {
		SetConvGoToIfBranchEnds(conv, m, w)
	}
}

func SetChoiceGoToIfBranchEnds(choice *Choice, m *MessagesData, w WhereToIfBranchEnds) {
	for _, conv := range choice.Convs {
		SetConvGoToIfBranchEnds(conv, m, w)
	}
}

func SetRecGoToIfBranchEnds(rec *Rec, m *MessagesData, w WhereToIfBranchEnds) {
	SetConvGoToIfBranchEnds(rec.Conv, m, w)
}

func SetConvGoToIfBranchEnds(conv *Conversation, m *MessagesData, w WhereToIfBranchEnds) {
	next := w
	id := ""
	typ := ""
	nodes := conv.Nodes
	for i := len(nodes) - 1; i >= 0; i-- {
		isBranchEnd := i == len(nodes)-1
		node := nodes[i]
		if node.Cat == "message" {
			if isBranchEnd {
				messageData, err := GetMessageDataWithId(m, node.Mess.Id)
				if err != nil {
					log.Fatal(err)
				}
				messageData.WhereToIfBranchEnds = w
			}
			message := node.Mess
			id = message.Id
			typ = "message"
		} else if node.Cat == "choice" {
			choiceData, err := GetChoiceDataWithId(m, node.Choice.Id)
			if err != nil {
				log.Fatal(err)
			}
			choiceData.WhereToIfBranchEnds = next
			id = choiceData.UniqueId
			typ = "choice"
			SetChoiceGoToIfBranchEnds(node.Choice, m, next)
		} else if node.Cat == "par" {
			par, err := GetParallelDataWithId(m, node.Par.Id)
			if err != nil {
				log.Fatal(err)
			}
			if isBranchEnd {
				par.WhereToIfBranchEnds = w
			}
			id = par.UniqueId
			typ = "par"
			parEnd := WhereToIfBranchEnds{Id: id, Type: typ, EndingPar: true}
			SetParallelGoToIfBranchEnds(node.Par, m, parEnd)
		} else if node.Cat == "rec" {
			rec, err := GetRecDataWithId(m, node.Rec.Id)
			if err != nil {
				log.Fatal(err)
			}
			if isBranchEnd {
				rec.WhereToIfBranchEnds = next
			}
			id = rec.UniqueId
			typ = "rec"
			SetRecGoToIfBranchEnds(node.Rec, m, next)
		} else if node.Cat == "continue" {
			cont, err := GetContinueDataWithId(m, node.Cont.Id)
			if err != nil {
				log.Fatal(err)
			}
			id = cont.UniqueId
			typ = "continue"
		} else {
			log.Fatal("Error, unknown Node.Cat encountered in SetConvGoToIfBranchEnds(): " + node.Cat)
		}
		next.Id = id
		next.Type = typ
	}
}

func SetGoToIfBranchEnds(p *Protocol, m *MessagesData) {
	w := WhereToIfBranchEnds{}
	firstConv := p.Locals[0].Conv
	SetConvGoToIfBranchEnds(firstConv, m, w)
}

func GetContinueToStructName(cont *ContinueData, m *MessagesData) string {
	rec := cont.Rec
	structName := GetFirstStructNameFromRecData(rec, m)
	return structName
}

func SetContinueTos(p *Protocol, m *MessagesData) {
	for _, mess := range m.Messages {
		followingContinueId := mess.FollowingContinueId
		if len(followingContinueId) > 0 {
			for _, cont := range m.Continues {
				if followingContinueId == cont.UniqueId {
					continueToStruct := GetContinueToStructName(cont, m)
					mess.ContinueToStruct = continueToStruct
					cont.ContinueToStruct = continueToStruct
				}
			}
		}
	}
}

func AddSeparatorUnderscoresToMessageSuffixes(m *MessagesData) {
	for _, mess := range m.Messages {
		mess.Suffix = AddUnderscoreSeparatorBetweenIntStrings(mess.Suffix)
	}
}

func GenerateHashMaps(m *MessagesData) {
	m.MessageMap = make(map[string]*MessageData)
	for _, mess := range m.Messages {
		m.MessageMap[mess.UniqueId] = mess
	}
	m.ChoiceMap = make(map[string]*ChoiceData)
	for _, choi := range m.Choices {
		m.ChoiceMap[choi.UniqueId] = choi
	}
	m.ParallelMap = make(map[string]*ParallelData)
	for _, par := range m.Parallels {
		m.ParallelMap[par.UniqueId] = par
	}
	m.ConversationMap = make(map[string]*ConversationData)
	for _, conv := range m.Conversations {
		m.ConversationMap[conv.UniqueId] = conv
	}
	m.RecMap = make(map[string]*RecData)
	for _, rec := range m.Recs {
		m.RecMap[rec.UniqueId] = rec
	}
	m.RecNameMap = make(map[string]*RecData)
	for _, rec := range m.Recs {
		m.RecNameMap[rec.Name] = rec
	}
	m.ContinueMap = make(map[string]*ContinueData)
	for _, cont := range m.Continues {
		m.ContinueMap[cont.UniqueId] = cont
	}
	m.MapsGenerated = true
}

type WhereToIfBranchEnds struct {
	Id        string
	Type      string
	EndingPar bool
}

type SequenceCountingData struct {
	RoleCounters []*RoleCountingData
}

type RoleCountingData struct {
	Name    string
	Counter int
}

type MessagesData struct {
	Messages        []*MessageData
	Choices         []*ChoiceData
	Parallels       []*ParallelData
	Conversations   []*ConversationData
	Recs            []*RecData
	Continues       []*ContinueData
	MessageMap      map[string]*MessageData
	ChoiceMap       map[string]*ChoiceData
	ParallelMap     map[string]*ParallelData
	ConversationMap map[string]*ConversationData
	RecMap          map[string]*RecData
	RecNameMap      map[string]*RecData
	ContinueMap     map[string]*ContinueData
	MapsGenerated   bool
}

func TranslateTree(p *Protocol) *MessagesData {
	m := TransTree(p)
	SetGoToIfBranchEnds(p, m)
	SetContinueTos(p, m)
	AddSeparatorUnderscoresToMessageSuffixes(m)
	GenerateHashMaps(m)
	return m
}
